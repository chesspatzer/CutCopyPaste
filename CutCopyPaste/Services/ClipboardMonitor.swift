import AppKit
import AppKit.NSSound
import Combine
import os

final class ClipboardMonitor: ObservableObject {
    private let pasteboard = NSPasteboard.general
    private var timer: Timer?
    private var lastChangeCount: Int
    private let storageService: StorageService
    private let exclusionManager: ExclusionListManager
    private let workspaceDetector = WorkspaceDetector()
    private let logger = Logger(subsystem: "com.cutcopypaste.app", category: "ClipboardMonitor")

    @Published var isMonitoring: Bool = false
    @Published var skipNextCapture: Bool = false {
        didSet {
            if skipNextCapture {
                skipResetTimer?.invalidate()
                skipResetTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: false) { [weak self] _ in
                    DispatchQueue.main.async {
                        self?.skipNextCapture = false
                    }
                }
            } else {
                skipResetTimer?.invalidate()
                skipResetTimer = nil
            }
        }
    }

    private var skipResetTimer: Timer?

    /// Poll interval reads from user preferences.
    private var pollInterval: TimeInterval {
        UserPreferences.shared.clipboardCheckInterval
    }

    /// Callback fired when a new item is captured, for UI refresh.
    var onNewItem: (() -> Void)?

    /// Rule engine for auto-transforms
    var ruleEngine: ClipboardRuleEngine?

    init(storageService: StorageService, exclusionManager: ExclusionListManager) {
        self.storageService = storageService
        self.exclusionManager = exclusionManager
        self.lastChangeCount = pasteboard.changeCount
    }

    func startMonitoring() {
        guard !isMonitoring else { return }
        isMonitoring = true
        lastChangeCount = pasteboard.changeCount

        timer = Timer.scheduledTimer(withTimeInterval: pollInterval, repeats: true) { [weak self] _ in
            self?.checkForChanges()
        }
        // Fire during UI tracking mode too (when popover is open)
        RunLoop.current.add(timer!, forMode: .common)
        logger.info("Clipboard monitoring started")
    }

    func stopMonitoring() {
        timer?.invalidate()
        timer = nil
        isMonitoring = false
        logger.info("Clipboard monitoring stopped")
    }

    func restartMonitoring() {
        guard isMonitoring else { return }
        stopMonitoring()
        startMonitoring()
    }

    // MARK: - Change Detection

    private func checkForChanges() {
        let currentCount = pasteboard.changeCount
        guard currentCount != lastChangeCount else { return }
        lastChangeCount = currentCount

        // Check for concealed/transient pasteboard types (password managers, etc.)
        if UserPreferences.shared.respectConcealedTypes {
            let concealedTypes: [NSPasteboard.PasteboardType] = [
                .init("org.nspasteboard.ConcealedType"),
                .init("org.nspasteboard.TransientType"),
                .init("org.nspasteboard.AutoGeneratedType"),
            ]
            if let types = pasteboard.types, concealedTypes.contains(where: types.contains) {
                logger.debug("Skipping capture — concealed/transient pasteboard type detected")
                return
            }
        }

        // Skip next capture (one-shot)
        if skipNextCapture {
            skipNextCapture = false
            logger.debug("Skipping capture — skip-next was active")
            return
        }

        // Check source app exclusion
        let frontApp = NSWorkspace.shared.frontmostApplication
        let bundleID = frontApp?.bundleIdentifier
        if let bundleID, exclusionManager.isExcluded(bundleID: bundleID) {
            logger.debug("Skipping capture from excluded app: \(bundleID)")
            return
        }

        // Extract and store
        guard let item = extractClipboardContent() else { return }

        // Detect workspace context
        if let workspace = workspaceDetector.detectCurrentWorkspace() {
            item.workspacePath = workspace.path
            item.workspaceName = workspace.name
            item.workspaceType = workspace.type.rawValue
        }

        // Detect sensitive data
        if UserPreferences.shared.detectSensitiveData, let text = item.textContent {
            let matches = SensitiveDataDetector.shared.detect(in: text)
            if !matches.isEmpty {
                item.sensitiveDataTypes = matches.map(\.type.rawValue)
                if UserPreferences.shared.autoMaskSensitive {
                    item.isMasked = true
                }
            }
        }

        // Summarize long text
        if let text = item.textContent, TextSummarizer.shared.shouldSummarize(text) {
            item.summary = TextSummarizer.shared.summarize(text).oneLiner
        }

        // Detect markdown first — markdown documents contain code keywords
        // in prose which causes false positives for language detection
        if let text = item.textContent {
            item.isMarkdown = MarkdownRenderer.isMarkdown(text)

            // Only detect programming language if not markdown
            if !item.isMarkdown {
                item.detectedLanguage = SyntaxHighlighter.shared.detectLanguage(text)
            }
        }

        Task {
            // Apply clipboard rules (auto-transforms)
            if let text = item.textContent, let ruleEngine {
                let transformed = await ruleEngine.applyRules(
                    to: text,
                    contentType: item.contentType,
                    sourceBundleID: bundleID
                )
                if transformed != text {
                    item.textContent = transformed
                    item.characterCount = transformed.count
                }
            }

            // Auto OCR for images
            if UserPreferences.shared.autoOCR,
               item.contentType == .image,
               let imageData = item.imageData {
                let text = try? await OCRService.shared.extractText(from: imageData)
                if let text, !text.isEmpty {
                    item.ocrText = text
                }
            }

            // Compute semantic embedding for search
            if let text = item.textContent ?? item.ocrText {
                if let vector = SemanticSearchService.shared.computeEmbedding(for: text) {
                    item.embeddingVector = SemanticSearchService.vectorToData(vector)
                }
            }

            // Deduplication check
            if UserPreferences.shared.deduplicateConsecutive,
               await storageService.isDuplicateOfMostRecent(item.textContent, contentType: item.contentType) {
                await storageService.touchMostRecent()
                return
            }

            await storageService.save(item)

            await MainActor.run {
                // Play capture sound
                if UserPreferences.shared.playSoundOnCopy {
                    NSSound(named: .init("Tink"))?.play()
                }

                self.onNewItem?()
            }
        }
    }

    // MARK: - Content Extraction

    private func extractClipboardContent() -> ClipboardItem? {
        let frontApp = NSWorkspace.shared.frontmostApplication
        let bundleID = frontApp?.bundleIdentifier
        let appName = frontApp?.localizedName

        // 1. Files
        if let fileURLs = pasteboard.readObjects(
            forClasses: [NSURL.self],
            options: [.urlReadingFileURLsOnly: true]
        ) as? [URL], !fileURLs.isEmpty {
            return ClipboardItem(
                contentType: .file,
                filePaths: fileURLs.map(\.path),
                sourceAppBundleID: bundleID,
                sourceAppName: appName
            )
        }

        // 2. Images
        if let image = NSImage(pasteboard: pasteboard),
           let tiff = image.tiffRepresentation {
            let bitmapRep = NSBitmapImageRep(data: tiff)
            let pngData = bitmapRep?.representation(using: .png, properties: [:])
            let thumbnail = image.resizedForThumbnail(maxSize: 64)

            return ClipboardItem(
                contentType: .image,
                imageData: pngData,
                thumbnailData: thumbnail,
                sourceAppBundleID: bundleID,
                sourceAppName: appName
            )
        }

        // 3. Rich text
        if let rtfData = pasteboard.data(forType: .rtf) {
            let plainText: String?
            if let attrString = NSAttributedString(rtf: rtfData, documentAttributes: nil) {
                plainText = attrString.string
            } else {
                plainText = nil
            }

            return ClipboardItem(
                contentType: .richText,
                textContent: plainText,
                rtfData: rtfData,
                sourceAppBundleID: bundleID,
                sourceAppName: appName
            )
        }

        // 4. Plain text (also detect URLs)
        if let text = pasteboard.string(forType: .string), !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
            let isLink = trimmed.hasPrefix("http://") || trimmed.hasPrefix("https://")

            return ClipboardItem(
                contentType: isLink ? .link : .text,
                textContent: text,
                sourceAppBundleID: bundleID,
                sourceAppName: appName
            )
        }

        return nil
    }
}
